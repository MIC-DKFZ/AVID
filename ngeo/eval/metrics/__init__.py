###AVIDHEADER

import os
import logging
import datetime
import subprocess
import shutil

from avid.common.artefact import defaultProps
from ngeo.eval.dataSetEvaluator import DataSetEvaluator
from avid.common.artefact.fileHelper import loadArtefactList_xml
from ngeo.eval import EvaluationResult

logger = logging.getLogger(__name__)

class DefaultMetric (object):
  '''Base class for metrics. A metric implements a method to
  evaluate an avid workflow according to result artefacts it produces. In
  order to evaluate, the metric uses the specified criteria.'''
  
  def __init__(self, metricCriteria, sessionDir, svWeights = None, instanceDefiningProps = [defaultProps.CASE], clearSessionDir = True):
    '''Initialization of the metric.
    @param metricCriteria: list of criterion instances that should be used to
    evaluate.
    @param sessionDir: specifies the directory where the session for evaluation will be created. 
    @param instanceDefiningProps: List of artefact properties that discriminate
    evaluation instances. E.g. as a default, the case property will be used to
    discriminate evaluation instances, thus one instance evaluation per case.
    @param svWeights: Weights that should be used when computing the single value
    measurement by summing up the measurements of all criteria. It is a dictionary
    with the measurement value IDs as keys and the weights as values. All
    measurement values not declared in the dict are assumed to have a weight of 0.
    Passing None implies that everything has a weight of 1.
    @param cleareSessionDir: Indicates of the metric should remove all artefacts
     generated by an evaluation or if they should be kept on disk.
    ''' 
    self._metricCriteria = metricCriteria
    self._instanceDefiningProps = instanceDefiningProps
    self.sessionDir = sessionDir
    self._svWeights = svWeights
    self._clearSessionDir = clearSessionDir
    
    
  def evaluate(self, workflowFile, artefactFile, workflowModifier = {}, label = None):
    '''Function is called to evaluate a workflow used the passed artfact definitions
    @param workflowFile: String defining the path to the avid workflow that should
    be executed.
    @param artefactFile: String defining the path to the artefact bootstrap file
     for the workflow session that will be evaluated.
    @param workflowModifier: Dict that defines the modifier for the workflow.
    They will be passed as arguments to the workflow execution. Key is the argument
    name and the dict value the argument value. The default implementation will
    generate an cl argument signature like --<key> <value>. Thus {'a':120} will
    be "--a 120". To change this behavior, override MetricBase._generateWorkflowCall(...)
    @param label: You can specify a label that is used by the metric when defining
    the workflow session path. If not specified a unique label will be generated.
    @return: Returns a EvaluationResult instance with everything you want to know.
    '''
    sessionFile,sessionName = self._generateSessionPath(label)
    callStr = self._generateWorkflowCall(workflowFile, sessionFile, sessionName, artefactFile, workflowModifier)
    
    global logger
    logger.debug('Evaluate workflow. workflow file: "%s"; artefact file: "%s"; workflow modifier: "%s"; session: "%s"', workflowFile, artefactFile, workflowModifier, sessionFile)
    logger.debug('Starting workflow processing... Call: "%s"', callStr)

    subprocess.call(callStr)
    
    logger.debug('Evaluating workflow results...')
    
    evaluator = DataSetEvaluator(self._metricCriteria, self._instanceDefiningProps)
    
    artefacts = loadArtefactList_xml(sessionFile, True, self.sessionDir)
    
    gmeasure, imeasure = evaluator.evaluate(artefacts)
       
    if self._clearSessionDir:
      artefactDir = os.path.join(self.sessionDir, sessionName)
      logger.debug('Remove session directory after evaluation. Dir: "%s"', artefactDir)
      
      try:
        shutil.rmtree(artefactDir)
        os.remove(sessionFile)
        os.remove(sessionFile+os.extsep+'log')
      except:
        logger.debug('Unkown error when clearing the session dir.')       
    
    result = EvaluationResult(gmeasure, imeasure, sessionName, workflowFile, artefactFile, workflowModifier, self._svWeights, self.valueNames, self.valueDescriptions)
      
    return result


  def _generateWorkflowCall(self, workflowFile, sessionFile, sessionName, artefactFile, workflowModifier = {}):
    '''Helper function generating the cl call that runs the workflow
    @param workflowFile: String defining the path to the avid workflow that should
    be executed.
    @param sessionFile: Path where the session of the workflow call should be stored.
    @param sessionName: Name of the session of the workflow call.
    @param artefactFile: String defining the path to the artefact bootstrap file
     for the workflow session that will be evaluated.
    @param workflowModifier: Dict that defines the modifier for the workflow.
    They will be passed as arguments to the workflow execution. Key is the argument
    name and the dict value the argument value. The default implementation will
    generate an cl argument signature like --<key> <value>. Thus {'a':120} will
    be "--a 120". To change this behavior, override MetricBase._generateWorkflowCall(...)
    @return: Returns a EvaluationResult instance with everythin you want to know.
    '''
    
    callStr = 'python "'+workflowFile\
      +'" --sessionPath "'+sessionFile\
      +'" --name "'+sessionName\
      +'" --bootstrapArtefacts "'+artefactFile\
      +'" --overwriteExistingSession --autoSave'
      
    for modKey in workflowModifier:
      callStr = callStr+' --'+str(modKey)+' "'+str(workflowModifier[modKey])+'"'     
      
    return callStr
    
    
  def _generateSessionPath(self, label = None):
    '''Helper function that returns a tuple (<path to the session file>, <session directory>)'''
    name = label
    if label is None:
      name = datetime.datetime.now().strftime("EvalSession_%Y-%m-%d_%H-%M-%S")
    
    return (os.path.join(self.sessionDir, name+os.extsep+"avid"), name) 

  @property
  def valueNames(self):
    '''Returns a dict with all valueID:valueNames of measurements the metric (and
    it criteria) generates.'''
    
    result = dict()

    for criterion in self._metricCriteria:
      result.update(criterion.valueNames)
    
    return result

  @property
  def valueDescriptions(self):
    '''Returns a dict with all valueID:valueDescriptions of measurements the metric (and
    it criteria) generates.'''
    
    result = dict()

    for criterion in self._metricCriteria:
      result.update(criterion.valueDescriptions)
    
    return result
    
